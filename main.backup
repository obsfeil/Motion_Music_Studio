/**
 * @file main.c  
 * @brief MSPM0G3507 Synthesizer - FINAL FIXED VERSION
 * @version 3.0.0 - No floating-point in main loop
 */

#include <math.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include "ti_msp_dl_config.h"
#include "main.h"


volatile SynthState_t gSynthState; 
static uint32_t phase = 0;
static uint32_t phase_increment = 0;

static const int16_t sine_table[256] = {
    0, 25, 49, 74, 98, 122, 147, 171, 195, 219, 243, 267, 290, 314, 337, 360,
    383, 405, 428, 450, 471, 493, 514, 535, 555, 575, 595, 614, 633, 652, 670, 687,
    704, 721, 737, 753, 768, 783, 797, 811, 824, 837, 849, 860, 871, 882, 892, 901,
    910, 918, 926, 933, 939, 945, 951, 955, 960, 963, 966, 969, 971, 972, 973, 974,
    974, 973, 972, 971, 969, 966, 963, 960, 955, 951, 945, 939, 933, 926, 918, 910,
    901, 892, 882, 871, 860, 849, 837, 824, 811, 797, 783, 768, 753, 737, 721, 704,
    687, 670, 652, 633, 614, 595, 575, 555, 535, 514, 493, 471, 450, 428, 405, 383,
    360, 337, 314, 290, 267, 243, 219, 195, 171, 147, 122, 98, 74, 49, 25, 0,
    -25, -49, -74, -98, -122, -147, -171, -195, -219, -243, -267, -290, -314, -337, -360, -383,
    -405, -428, -450, -471, -493, -514, -535, -555, -575, -595, -614, -633, -652, -670, -687, -704,
    -721, -737, -753, -768, -783, -797, -811, -824, -837, -849, -860, -871, -882, -892, -901, -910,
    -918, -926, -933, -939, -945, -951, -955, -960, -963, -966, -969, -971, -972, -973, -974, -974,
    -973, -972, -971, -969, -966, -963, -960, -955, -951, -945, -939, -933, -926, -918, -910, -901,
    -892, -882, -871, -860, -849, -837, -824, -811, -797, -783, -768, -753, -737, -721, -704, -687,
    -670, -652, -633, -614, -595, -575, -555, -535, -514, -493, -471, -450, -428, -405, -383, -360,
    -337, -314, -290, -267, -243, -219, -195, -171, -147, -122, -98, -74, -49, -25
};

static void Process_Input(void);
static void Generate_Audio_Sample(void);
static void Update_Audio_Params(void);
static void Process_Buttons(void);

int main(void) {
    SYSCFG_DL_init();
    
    memset((void*)&gSynthState, 0, sizeof(SynthState_t));
    gSynthState.frequency = FREQ_DEFAULT;
    gSynthState.volume = VOLUME_DEFAULT;
    gSynthState.waveform = WAVE_SINE;
    gSynthState.mode = MODE_SYNTH;
    gSynthState.audio_playing = 1;
    
    Update_Audio_Params();
    
    DL_ADC12_enableConversions(ADC_MIC_JOY_INST);
    DL_ADC12_startConversion(ADC_MIC_JOY_INST);
    DL_ADC12_enableConversions(ADC_ACCEL_INST);
    DL_ADC12_startConversion(ADC_ACCEL_INST);
    
    NVIC_EnableIRQ(ADC0_INT_IRQn);
    NVIC_EnableIRQ(ADC1_INT_IRQn);
    NVIC_EnableIRQ(TIMG7_INT_IRQn);
    NVIC_EnableIRQ(GPIOA_INT_IRQn);
    
    DL_GPIO_clearPins(GPIO_RGB_PORT, GPIO_RGB_RED_PIN | GPIO_RGB_GREEN_PIN | GPIO_RGB_BLUE_PIN);
    DL_GPIO_setPins(GPIO_RGB_PORT, GPIO_RGB_GREEN_PIN);
    
    uint32_t loop_counter = 0;
    
    while (1) {
        // Call LESS often to avoid float crash!
        if (loop_counter % 10000 == 0) {
            Process_Input();
        }
        
        if (loop_counter % 5000 == 0) {
            Process_Buttons();
        }
        
        if (loop_counter % 100000 == 0) {
            DL_GPIO_togglePins(GPIO_RGB_PORT, GPIO_RGB_BLUE_PIN);
        }
        
        loop_counter++;
    }
}

void TIMG7_IRQHandler(void) {
    if (DL_Timer_getPendingInterrupt(TIMER_SAMPLE_INST) == DL_TIMER_IIDX_ZERO) {
        gSynthState.timer_count++;
        if (gSynthState.audio_playing) {
            Generate_Audio_Sample();
        } else {
            DL_TimerG_setCaptureCompareValue(PWM_AUDIO_INST, 2048, DL_TIMER_CC_0_INDEX);
        }
    }
}

void ADC0_IRQHandler(void) {
    gSynthState.adc0_count++;
    switch (DL_ADC12_getPendingInterrupt(ADC_MIC_JOY_INST)) {
        case DL_ADC12_IIDX_MEM0_RESULT_LOADED:
            gSynthState.mic_level = DL_ADC12_getMemResult(ADC_MIC_JOY_INST, DL_ADC12_MEM_IDX_0);
            break;
        case DL_ADC12_IIDX_MEM1_RESULT_LOADED:
            gSynthState.joy_y = DL_ADC12_getMemResult(ADC_MIC_JOY_INST, DL_ADC12_MEM_IDX_1);
            break;
        case DL_ADC12_IIDX_MEM2_RESULT_LOADED:
            gSynthState.joy_x = DL_ADC12_getMemResult(ADC_MIC_JOY_INST, DL_ADC12_MEM_IDX_2);
            break;
        default:  // ⭐ LEGG TIL DENNE!
            break;
    }
}

void ADC1_IRQHandler(void) {
    gSynthState.adc1_count++;
    switch (DL_ADC12_getPendingInterrupt(ADC_ACCEL_INST)) {
        case DL_ADC12_IIDX_MEM0_RESULT_LOADED:
            gSynthState.accel_x = (int16_t)DL_ADC12_getMemResult(ADC_ACCEL_INST, DL_ADC12_MEM_IDX_0);
            break;
        case DL_ADC12_IIDX_MEM1_RESULT_LOADED:
            gSynthState.accel_y = (int16_t)DL_ADC12_getMemResult(ADC_ACCEL_INST, DL_ADC12_MEM_IDX_1);
            break;
        case DL_ADC12_IIDX_MEM2_RESULT_LOADED:
            gSynthState.accel_z = (int16_t)DL_ADC12_getMemResult(ADC_ACCEL_INST, DL_ADC12_MEM_IDX_2);
            break;
        default:  // ⭐ LEGG TIL DENNE!
            break;
    }
}

static void Update_Audio_Params(void) {
    phase_increment = (uint32_t)((gSynthState.frequency * 4294967296.0) / SAMPLE_RATE);
}

static void Generate_Audio_Sample(void) {
    if (gSynthState.volume == 0) { 
        DL_TimerG_setCaptureCompareValue(PWM_AUDIO_INST, 2048, DL_TIMER_CC_0_INDEX);
        return;
    }

    int16_t sample = 0;
    uint8_t index = (uint8_t)((phase >> 24) & 0xFF);
    
    switch (gSynthState.waveform) {
        case WAVE_SINE:
            sample = sine_table[index];
            break;
        case WAVE_SQUARE:
            sample = (index < 128) ? 800 : -800;
            break;
        case WAVE_SAWTOOTH:
            sample = (int16_t)(((int32_t)index * 1600 / 256) - 800);
            break;
        case WAVE_TRIANGLE:
            sample = (index < 128) ? (int16_t)(((int32_t)index * 1600 / 128) - 800) 
                                   : (int16_t)(800 - ((int32_t)(index - 128) * 1600 / 128));
            break;
        default:
            sample = sine_table[index];
            break;
    }

    sample = (int16_t)((sample * gSynthState.volume) / 100);
    
    int32_t val = 2048 + sample;
    if(val < 1) val = 1;
    if(val > 4095) val = 4095;
    
    DL_TimerG_setCaptureCompareValue(PWM_AUDIO_INST, (uint16_t)val, DL_TIMER_CC_0_INDEX);
    phase += phase_increment;
}

static void Process_Input(void) {
    uint32_t raw_val;
    uint32_t freq_int;

    // 1. BESTEM FREKVENS-KILDE
    if (gSynthState.mode == MODE_THEREMIN) {
        // Bruk akselerometer X. Mapper råverdi (-2048 til 2047) til 0-4095
        raw_val = (uint32_t)(gSynthState.accel_x + 2048);
    } else {
        // Bruk joystick X
        raw_val = gSynthState.joy_x;
    }

    // 2. BEREGN FREKVENS (Heltallsmatematikk for hastighet)
    if (raw_val > 100) {
        // Bruker grensene fra main.h (f.eks. 100 Hz til 8000 Hz)
        freq_int = (uint32_t)FREQ_MIN_HZ + 
                   ((raw_val * (uint32_t)(FREQ_MAX_HZ - FREQ_MIN_HZ)) / 4095);
        
        uint32_t curr_freq = (uint32_t)gSynthState.frequency;
        uint32_t diff = (freq_int > curr_freq) ? (freq_int - curr_freq) : (curr_freq - freq_int);
        
        // Oppdater kun ved signifikant endring for å unngå "jitter"
        if (diff > 10) {
            gSynthState.frequency = (float)freq_int;
            Update_Audio_Params(); // Denne beregner phase_increment for 20kHz
        }
    }
    
    // 3. VOLUM (Bruker alltid Joystick Y i dette eksempelet)
    if (gSynthState.joy_y > 100) {
        uint8_t new_vol = (uint8_t)((gSynthState.joy_y * 100) / 4095);
        if (new_vol != gSynthState.volume) {
            gSynthState.volume = new_vol;
        }
    }
}
static void Process_Buttons(void) {
    static uint32_t s1_prev = 1, s2_prev = 1;
    uint32_t s1 = DL_GPIO_readPins(GPIO_BUTTONS_PORT, GPIO_BUTTONS_S1_PIN);
    uint32_t s2 = DL_GPIO_readPins(GPIO_BUTTONS_PORT, GPIO_BUTTONS_S2_PIN);
    
    if (s1 == 0 && s1_prev != 0) {
        gSynthState.waveform = (gSynthState.waveform + 1) % WAVE_COUNT;
        DL_GPIO_togglePins(GPIO_RGB_PORT, GPIO_RGB_RED_PIN);
        while (DL_GPIO_readPins(GPIO_BUTTONS_PORT, GPIO_BUTTONS_S1_PIN) == 0);
    }
    
    if (s2 == 0 && s2_prev != 0) {
        gSynthState.audio_playing = !gSynthState.audio_playing;
        if (gSynthState.audio_playing) {
            DL_GPIO_setPins(GPIO_RGB_PORT, GPIO_RGB_GREEN_PIN);
        } else {
            DL_GPIO_clearPins(GPIO_RGB_PORT, GPIO_RGB_GREEN_PIN);
        }
        while (DL_GPIO_readPins(GPIO_BUTTONS_PORT, GPIO_BUTTONS_S2_PIN) == 0);
    }
    
    s1_prev = s1;
    s2_prev = s2;
}

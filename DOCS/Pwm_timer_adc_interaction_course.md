# ğŸ“ PWM, TIMER & ADC SAMSPILL - Komplett Kurs

## ğŸ“š INNHOLDSFORTEGNELSE

1. [Oversikt - The Big Picture](#overview)
2. [Timer som Koordinator](#timer-coordinator)
3. [ADC Triggering og Timing](#adc-timing)
4. [PWM Audio Generation](#pwm-audio)
5. [Interrupt Choreography](#interrupts)
6. [Real-World Example: Synthesizer](#synthesizer-example)
7. [Timing Diagrams](#timing-diagrams)
8. [Common Pitfalls](#pitfalls)
9. [Advanced Techniques](#advanced)

---

## ğŸŒ 1. OVERSIKT - THE BIG PICTURE {#overview}

### **Hvordan de tre modulene jobber sammen i et audio synthesizer:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SYNTHESIZER SYSTEM                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  TIMER   â”‚â”€â”€â”€â”€â”€â”€â”€â”€>â”‚   ADC    â”‚â”€â”€â”€â”€â”€â”€â”€â”€>â”‚   CPU    â”‚
    â”‚  (8 kHz) â”‚ Trigger â”‚ (Sample) â”‚ Result  â”‚ (Process)â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
         â”‚                                          â”‚
         â”‚ Interrupt                                â”‚ Update
         â”‚                                          â”‚ Duty Cycle
         v                                          v
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   CPU    â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚   PWM    â”‚
    â”‚  (Wake)  â”‚                               â”‚  (Audio) â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                     â”‚
                                                     v
                                               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                               â”‚ Speaker  â”‚
                                               â”‚ /Buzzer  â”‚
                                               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### **Dataflow:**

```
1. TIMER generates 8 kHz interrupt (every 125 Âµs)
   â””â”€> Triggers ADC conversion
   â””â”€> Wakes CPU

2. ADC samples joystick/sensors
   â””â”€> Stores result in memory
   â””â”€> Generates interrupt when done

3. CPU processes ADC data
   â””â”€> Calculates audio waveform
   â””â”€> Updates PWM duty cycle

4. PWM outputs audio signal
   â””â”€> Carrier frequency: 977 Hz
   â””â”€> Duty cycle modulated by audio sample
   â””â”€> Low-pass filtered to audio
```

---

## â° 2. TIMER SOM KOORDINATOR {#timer-coordinator}

### **2.1 Timer Role: The Master Clock**

Timer fungerer som **master timekeeper** for hele systemet:

```c
// SysConfig konfigurasjon:
TIMER1.$name = "TIMER_SAMPLE";
TIMER1.timerPeriod = "125 us";        // 8 kHz sample rate
TIMER1.interrupts = ["ZERO"];         // Interrupt on zero
TIMER1.timerMode = "PERIODIC_UP";     // Continuous counting
TIMER1.timerStartTimer = true;        // Auto-start
```

**Hva skjer:**
```
Timer counter: 0 â†’ 1 â†’ 2 â†’ ... â†’ MAX â†’ 0 (overflow)
                                        â†‘
                                   Interrupt!
```

### **2.2 Timer Frequency Calculation**

```javascript
// I SysConfig:
TIMER1.timerPeriod = "125 us";

// Dette oversettes til:
Timer_Clock = 32 MHz (BUSCLK)
Timer_Period = 125 Âµs

Timer_Count = Timer_Clock Ã— Timer_Period
            = 32,000,000 Hz Ã— 0.000125 s
            = 4000 cycles

// Hver 4000 cycles â†’ Interrupt
Interrupt_Frequency = 32 MHz / 4000 = 8 kHz
```

### **2.3 Timer Interrupt Service Routine (ISR)**

```c
// Generated by SysConfig:
void TIMG7_IRQHandler(void) {
    // Check interrupt flag
    uint32_t status = DL_Timer_getInterruptStatus(TIMER_SAMPLE_INST);
    
    if (status & DL_TIMER_INTERRUPT_ZERO) {
        // Timer reached zero - triggered every 125 Âµs
        
        // YOUR CODE HERE:
        // 1. Read ADC results (joystick position)
        // 2. Calculate next audio sample
        // 3. Update PWM duty cycle
        
        // Set flag to wake main loop
        timer_flag = true;
    }
}
```

**Viktig konsept:**
- Timer ISR kjÃ¸rer **hver 125 Âµs** (8000 ganger per sekund)
- Dette definerer **sample rate** for audio systemet
- Alt som skjer mÃ¥ fullfÃ¸res fÃ¸r neste interrupt!

---

## ğŸ”¬ 3. ADC TRIGGERING OG TIMING {#adc-timing}

### **3.1 ADC Conversion Process**

```
ADC Conversion Pipeline:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Trigger â”‚â”€â”€â”€>â”‚  Sample  â”‚â”€â”€â”€>â”‚ Convert  â”‚â”€â”€â”€>â”‚  Store   â”‚
â”‚          â”‚    â”‚ (125 Âµs) â”‚    â”‚ (~0.5Âµs) â”‚    â”‚ Result   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â†‘                                                 â”‚
     â”‚                                                 â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    ADC_DONE Interrupt
```

### **3.2 ADC Configuration for Multiple Channels**

```javascript
// SysConfig ADC0 (Joystick + Mikrofon):
ADC121.samplingOperationMode = "sequence";  // Sample multiple channels
ADC121.endAdd = 2;                         // Sample 3 channels (0, 1, 2)
ADC121.repeatMode = true;                  // Auto-repeat after sequence

// Channel assignment:
ADC121.adcMem0chansel = "DL_ADC12_INPUT_CHAN_0";  // Mikrofon (PA27)
ADC121.adcMem1chansel = "DL_ADC12_INPUT_CHAN_1";  // Joy Y (PA26)
ADC121.adcMem2chansel = "DL_ADC12_INPUT_CHAN_2";  // Joy X (PA25)
```

**Sequence timing:**
```
Total conversion time per sequence:
T_total = T_sample Ã— (endAdd + 1)
        = 125 Âµs Ã— 3
        = 375 Âµs

Effective sample rate per channel:
Rate = 1 / T_total
     = 1 / 375 Âµs
     = ~2667 Hz per channel
```

### **3.3 ADC Interrupt Handling**

```c
// ADC0 ISR - called after each channel conversion:
void ADC0_IRQHandler(void) {
    uint32_t status = DL_ADC12_getInterruptStatus(ADC_MIC_JOY_INST);
    
    if (status & DL_ADC12_INTERRUPT_MEM0_RESULT_LOADED) {
        // Channel 0 (Mikrofon) ready
        adc_mic = DL_ADC12_getMemResult(ADC_MIC_JOY_INST, DL_ADC12_MEM_IDX_0);
    }
    
    if (status & DL_ADC12_INTERRUPT_MEM1_RESULT_LOADED) {
        // Channel 1 (Joy Y) ready
        adc_joy_y = DL_ADC12_getMemResult(ADC_MIC_JOY_INST, DL_ADC12_MEM_IDX_1);
    }
    
    if (status & DL_ADC12_INTERRUPT_MEM2_RESULT_LOADED) {
        // Channel 2 (Joy X) ready
        adc_joy_x = DL_ADC12_getMemResult(ADC_MIC_JOY_INST, DL_ADC12_MEM_IDX_2);
        
        // All channels done - process audio
        adc_sequence_complete = true;
    }
}
```

### **3.4 ADC Triggering Modes**

**Mode 1: Software Trigger (Simple)**
```c
// In timer ISR:
void TIMG7_IRQHandler(void) {
    // Manually trigger ADC conversion
    DL_ADC12_startConversion(ADC_MIC_JOY_INST);
}
```

**Mode 2: Hardware Trigger (Advanced)**
```javascript
// SysConfig can configure timer to auto-trigger ADC:
ADC121.trigSrc = "DL_ADC12_TRIG_SRC_EVENT";  // Hardware event trigger
// Then connect timer event to ADC trigger in event routing
```

**Mode 3: Free-Running (Background)**
```c
// Start ADC once, it runs continuously:
void init_adc(void) {
    DL_ADC12_enableConversions(ADC_MIC_JOY_INST);
    DL_ADC12_startConversion(ADC_MIC_JOY_INST);
    // ADC now samples continuously in background
}
```

---

## ğŸµ 4. PWM AUDIO GENERATION {#pwm-audio}

### **4.1 PWM Basic Principle**

```
PWM Signal (Carrier 977 Hz):
     â”Œâ”€â”€â”  â”Œâ”€â”€â”  â”Œâ”€â”€â”  â”Œâ”€â”€â”
     â”‚  â”‚  â”‚  â”‚  â”‚  â”‚  â”‚  â”‚
â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”˜  â””â”€â”€â”˜  â””â”€â”€â”˜  â””â”€â”€â”€â”€â”€
|<â”€ T_period â”€>|
|<D>|          D = Duty cycle (variable)

Audio is encoded in duty cycle:
â”œâ”€ 0% duty   = Max negative voltage (after filter)
â”œâ”€ 50% duty  = Zero voltage (silence)
â””â”€ 100% duty = Max positive voltage
```

### **4.2 PWM Timer Configuration**

```javascript
// SysConfig PWM module:
PWM1.$name = "PWM_AUDIO";
PWM1.timerCount = 4095;              // 12-bit resolution
PWM1.pwmMode = "EDGE_ALIGN_UP";      // Standard PWM mode
PWM1.peripheral.$assign = "TIMG0";   // Use Timer Group 0
// Clock source: MFCLK (4 MHz) - implicit

// Calculation:
PWM_freq = Clock_freq / (timerCount + 1)
         = 4 MHz / 4096
         = 976.56 Hz (carrier frequency)
```

### **4.3 Updating PWM Duty Cycle**

```c
// Audio sample synthesis (in timer ISR):
void TIMG7_IRQHandler(void) {
    // Calculate next audio sample (-2048 to +2047)
    int16_t audio_sample = calculate_waveform(phase, frequency);
    
    // Convert to PWM duty cycle (0 to 4095)
    uint16_t duty_cycle = 2048 + audio_sample;  // Center at 50%
    
    // Update PWM immediately
    DL_TimerG_setCaptureCompareValue(
        PWM_AUDIO_INST,
        duty_cycle,
        DL_TIMER_CC_0_INDEX
    );
    
    // Advance phase for next sample
    phase += phase_increment;
}
```

### **4.4 PWM to Audio Conversion**

```
PWM Output (Digital):          After Low-Pass Filter (Analog):
     â”Œâ”€â”€â”  â”Œâ”€â”€â”€â”                      â•±â•²
     â”‚  â”‚  â”‚   â”‚                     â•±  â•²
â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”˜   â””â”€â”€â”€â”€â”€            â”€â”€â”€â•±    â•²â”€â”€â”€â”€
   50%   60%   40%                 Smooth sine wave

Low-pass filter cutoff: ~5 kHz
PWM carrier: 977 Hz (filtered out)
Audio content: 20 Hz - 4 kHz (passes through)
```

**Hardware RC Low-Pass Filter:**
```
PWM_OUT â”€â”€â”€â”€[R]â”€â”€â”€â”€â”¬â”€â”€â”€â”€ Filtered Audio Out
                   â”‚
                  [C]
                   â”‚
                  GND

R = 1 kÎ©, C = 100 nF
f_cutoff = 1 / (2Ï€ Ã— R Ã— C) â‰ˆ 1.6 kHz
```

---

## ğŸ¯ 5. INTERRUPT CHOREOGRAPHY {#interrupts}

### **5.1 Interrupt Priority**

```c
// In SysConfig:
TIMER1.interruptPriority = "1";  // High priority (lower number = higher priority)
ADC121.interruptPriority = "2";  // Medium priority
PWM1.interrupts = ["ZERO_EVENT"];  // Optional, usually not used for audio
```

**Priority hierarchy:**
```
Highest Priority (0) â† Fastest response needed
    â”‚
    â”œâ”€ TIMER_SAMPLE (Priority 1) â† Master clock, must be accurate
    â”œâ”€ ADC conversions (Priority 2) â† Important but can wait briefly
    â”œâ”€ GPIO buttons (Priority 3) â† User input, not time-critical
    â””â”€ Background tasks (Priority 7)
Lowest Priority (7)
```

### **5.2 Interrupt Nesting**

```c
// Example scenario:

void TIMG7_IRQHandler(void) {  // Priority 1
    // Timer interrupt starts
    
    DL_ADC12_startConversion(ADC_MIC_JOY_INST);  // Trigger ADC
    
    // If ADC completes before timer ISR finishes:
    // â†’ ADC ISR can interrupt this ISR (if higher priority)
    // â†’ Or ADC ISR waits until this ISR finishes (if lower priority)
    
    calculate_audio_sample();  // Takes time
    update_pwm_duty_cycle();
}

void ADC0_IRQHandler(void) {  // Priority 2
    // ADC interrupt - may nest inside timer ISR
    read_adc_results();
}
```

**Best practice:**
- Keep ISRs **SHORT** - minimize time in interrupt context
- Set flags, don't do heavy processing in ISR
- Process data in main loop when possible

### **5.3 Interrupt Timing Example**

```
Timeline (not to scale):

0 Âµs    â”œâ”€ Timer interrupt (TIMG7_IRQHandler)
        â”‚  â”œâ”€ Trigger ADC
        â”‚  â”œâ”€ Calculate audio sample (20 Âµs)
        â”‚  â””â”€ Update PWM duty cycle (5 Âµs)
25 Âµs   â”œâ”€ Timer ISR exits
        â”‚
30 Âµs   â”œâ”€ ADC conversion completes
        â”‚  â””â”€ ADC ISR (ADC0_IRQHandler)
        â”‚     â””â”€ Read results (5 Âµs)
35 Âµs   â”œâ”€ ADC ISR exits
        â”‚
125 Âµs  â”œâ”€ NEXT Timer interrupt
        â””â”€ Cycle repeats...
```

### **5.4 Critical Timing Constraint**

```c
// CRITICAL RULE:
// All processing MUST complete within 125 Âµs (timer period)

void TIMG7_IRQHandler(void) {
    // START: 0 Âµs
    
    read_adc_results();        // ~5 Âµs
    calculate_audio();         // ~20 Âµs
    update_pwm();              // ~5 Âµs
    update_lcd();              // ~50 Âµs âš ï¸ TOO SLOW!
    
    // TOTAL: ~80 Âµs (OK)
    // But if >125 Âµs â†’ MISS NEXT INTERRUPT! âŒ
}

// SOLUTION: Move slow tasks to main loop
void TIMG7_IRQHandler(void) {
    read_adc_results();        // ~5 Âµs
    calculate_audio();         // ~20 Âµs
    update_pwm();              // ~5 Âµs
    lcd_update_flag = true;    // Just set flag!
    // TOTAL: ~30 Âµs âœ…
}

void main(void) {
    while(1) {
        if (lcd_update_flag) {
            update_lcd();      // Do slow task here
            lcd_update_flag = false;
        }
    }
}
```

---

## ğŸ¹ 6. REAL-WORLD EXAMPLE: SYNTHESIZER {#synthesizer-example}

### **6.1 Complete System Architecture**

```c
// ============================================
// GLOBAL VARIABLES (volatile for ISR access)
// ============================================
volatile uint16_t adc_joy_x = 2048;
volatile uint16_t adc_joy_y = 2048;
volatile bool adc_ready = false;

static uint32_t phase = 0;           // Phase accumulator (NOT volatile!)
static uint32_t phase_increment = 0;  // Frequency control

// ============================================
// INITIALIZATION
// ============================================
void init_audio_system(void) {
    // 1. Initialize peripherals (done by SYSCFG_DL_init)
    SYSCFG_DL_init();
    
    // 2. Start PWM (audio output)
    DL_TimerG_startCounter(PWM_AUDIO_INST);
    
    // 3. Start sample timer (master clock)
    DL_TimerG_startCounter(TIMER_SAMPLE_INST);
    
    // 4. Enable interrupts
    NVIC_EnableIRQ(TIMER_SAMPLE_INT_IRQN);
    NVIC_EnableIRQ(ADC_MIC_JOY_INT_IRQN);
    
    // 5. Start ADC conversions
    DL_ADC12_enableConversions(ADC_MIC_JOY_INST);
    DL_ADC12_startConversion(ADC_MIC_JOY_INST);
}

// ============================================
// TIMER ISR - Called every 125 Âµs (8 kHz)
// ============================================
void TIMG7_IRQHandler(void) {
    switch (DL_TimerG_getPendingInterrupt(TIMER_SAMPLE_INST)) {
        case DL_TIMER_IIDX_ZERO:
            // 1. Calculate next audio sample
            phase += phase_increment;  // Advance phase
            
            // Generate sine wave (-2048 to +2047)
            int16_t sample = sine_lookup[(phase >> 24) & 0xFF];
            
            // 2. Update PWM duty cycle
            uint16_t duty = 2048 + sample;  // Offset to 0-4095
            DL_TimerG_setCaptureCompareValue(
                PWM_AUDIO_INST,
                duty,
                DL_TIMER_CC_0_INDEX
            );
            
            // 3. Set flag for main loop
            adc_ready = true;
            break;
    }
}

// ============================================
// ADC ISR - Called after each conversion
// ============================================
void ADC0_IRQHandler(void) {
    switch (DL_ADC12_getPendingInterrupt(ADC_MIC_JOY_INST)) {
        case DL_ADC12_IIDX_MEM2_RESULT_LOADED:
            // All channels converted
            adc_joy_x = DL_ADC12_getMemResult(ADC_MIC_JOY_INST, DL_ADC12_MEM_IDX_2);
            adc_joy_y = DL_ADC12_getMemResult(ADC_MIC_JOY_INST, DL_ADC12_MEM_IDX_1);
            break;
    }
}

// ============================================
// MAIN LOOP - Background processing
// ============================================
int main(void) {
    init_audio_system();
    
    while(1) {
        // Wait for timer interrupt
        if (adc_ready) {
            adc_ready = false;
            
            // Process joystick data (slow, non-critical)
            uint32_t frequency = map_joystick_to_frequency(adc_joy_x);
            phase_increment = frequency_to_phase_increment(frequency);
            
            // Update LCD (very slow, definitely not in ISR!)
            update_lcd_display(frequency);
        }
        
        // Low-power sleep until next interrupt
        __WFI();  // Wait For Interrupt
    }
}
```

### **6.2 Frequency Calculation**

```c
// Convert joystick position to frequency:
uint32_t map_joystick_to_frequency(uint16_t joy_x) {
    // joy_x range: 0 - 4095 (12-bit ADC)
    // Desired frequency range: 100 Hz - 2000 Hz
    
    // Linear mapping:
    uint32_t freq = 100 + ((joy_x * 1900) / 4095);
    return freq;
}

// Convert frequency to phase increment:
uint32_t frequency_to_phase_increment(uint32_t frequency) {
    // Phase accumulator: 32-bit, wraps at 2^32
    // Sample rate: 8000 Hz
    // Formula: phase_inc = (freq * 2^32) / sample_rate
    
    // Simplified (avoids 64-bit math):
    // phase_inc = (freq * 536871) >> 12  // 536871 â‰ˆ 2^32 / 8000
    
    return (frequency * 536871UL) >> 12;
}
```

### **6.3 Waveform Generation**

```c
// Sine lookup table (256 entries, 8-bit index):
const int16_t sine_lookup[256] = {
    0, 100, 200, 297, 392, 483, 569, 650,
    724, 792, 851, 903, 946, 980, 1004, 1019,
    1024, 1019, 1004, 980, 946, 903, 851, 792,
    // ... (full table)
};

// Fast sine generation using lookup + interpolation:
int16_t generate_sine(uint32_t phase) {
    // Extract 8-bit index from phase (top 8 bits)
    uint8_t index = (phase >> 24) & 0xFF;
    
    // Simple lookup (no interpolation):
    return sine_lookup[index];
}

// Square wave (even simpler):
int16_t generate_square(uint32_t phase) {
    return (phase & 0x80000000) ? 1024 : -1024;
}

// Sawtooth wave:
int16_t generate_sawtooth(uint32_t phase) {
    return (int16_t)((phase >> 21) - 1024);  // 11-bit â†’ Â±1024
}
```

---

## ğŸ“Š 7. TIMING DIAGRAMS {#timing-diagrams}

### **7.1 Normal Operation**

```
Timer (8 kHz):  â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬
                â”‚   125 Âµs      â”‚   125 Âµs      â”‚   125 Âµs      â”‚
                â”‚               â”‚               â”‚               â”‚
Timer ISR:      â”œâ”€â”             â”œâ”€â”             â”œâ”€â”             
                â”‚ â”‚ 30Âµs        â”‚ â”‚             â”‚ â”‚             
                â””â”€â”˜             â””â”€â”˜             â””â”€â”˜             
                                                                  
ADC Conv:         â”œâ”€â”€â”€â”€â”€â”€â”        â”œâ”€â”€â”€â”€â”€â”€â”        â”œâ”€â”€â”€â”€â”€â”€â”      
                  â”‚ 375Âµsâ”‚        â”‚ 375Âµsâ”‚        â”‚ 375Âµsâ”‚      
                  â””â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”˜      
                                                                  
ADC ISR:                â”œâ”              â”œâ”              â”œâ”       
                        â”‚5Âµs            â”‚5Âµs            â”‚5Âµs     
                        â””â”˜              â””â”˜              â””â”˜       
                                                                  
CPU Busy:       â”œâ”€â”     â”œâ”        â”œâ”€â”  â”œâ”        â”œâ”€â”  â”œâ”       
CPU Idle:       â””â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â†‘Sleep          â†‘WFI           â†‘WFI           
```

**Observations:**
- Timer ISR takes ~30 Âµs (audio calculation + PWM update)
- ADC conversion takes ~375 Âµs (3 channels Ã— 125 Âµs)
- CPU is idle ~70% of the time (power saving possible!)
- No timing conflicts - everything fits within 125 Âµs period

### **7.2 Overrun Condition (ERROR!)**

```
Timer (8 kHz):  â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬
                â”‚   125 Âµs      â”‚   125 Âµs      â”‚
                â”‚               â”‚               â”‚
Timer ISR:      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”œâ”€â”€â”€ âŒ MISSED!
                â”‚        150 Âµs!       â”‚         
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         
                â†‘ Too slow! Overran timer period!

Result:
â”œâ”€ Audio glitch (missed sample)
â”œâ”€ Frequency drift (timing error)
â””â”€ Potential system instability
```

**How to detect:**
```c
volatile uint32_t timer_overruns = 0;
static bool timer_active = false;

void TIMG7_IRQHandler(void) {
    if (timer_active) {
        // ISR called again before previous finished!
        timer_overruns++;
        return;  // Skip this sample
    }
    
    timer_active = true;
    
    // Do ISR work...
    calculate_audio();
    update_pwm();
    
    timer_active = false;
}
```

### **7.3 Multi-Channel ADC Timing**

```
Timer Trigger:  â†“
                â”‚
ADC Ch0 (Mic):  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚ 125Âµs  â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€ Result ready
                         â”‚
ADC Ch1 (JoyY): â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚        â”‚ 125Âµs  â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€ Result ready
                         â”‚        â”‚
ADC Ch2 (JoyX): â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚        â”‚        â”‚ 125Âµs  â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€ All done!
                         â”‚        â”‚        â”‚
Interrupts:              â†“        â†“        â†“
                        MEM0     MEM1     MEM2

Total time: 375 Âµs (3 Ã— 125 Âµs)
```

---

## âš ï¸ 8. COMMON PITFALLS {#pitfalls}

### **Pitfall 1: ISR Takes Too Long**

```c
// âŒ BAD: Heavy processing in ISR
void TIMG7_IRQHandler(void) {
    calculate_audio();      // 20 Âµs - OK
    update_lcd();           // 50 Âµs - SLOW
    send_uart_data();       // 100 Âµs - WAY TOO SLOW!
    process_fft();          // 500 Âµs - DISASTER!
    // Total: 670 Âµs >> 125 Âµs timer period! âŒ
}

// âœ… GOOD: Minimal ISR, flags for main loop
void TIMG7_IRQHandler(void) {
    calculate_audio();      // 20 Âµs - OK
    update_pwm();           // 5 Âµs - OK
    lcd_update_needed = true;      // Just set flags
    uart_send_needed = true;
    fft_needed = true;
    // Total: 25 Âµs âœ…
}

void main(void) {
    while(1) {
        if (lcd_update_needed) {
            update_lcd();  // Slow tasks in main loop
            lcd_update_needed = false;
        }
        // ... handle other flags
        __WFI();  // Sleep until next interrupt
    }
}
```

### **Pitfall 2: Missing `volatile` Keyword**

```c
// âŒ BAD: Compiler optimizes away shared variable
uint16_t adc_result = 0;  // NOT volatile!

void ADC0_IRQHandler(void) {
    adc_result = DL_ADC12_getMemResult(...);  // ISR writes
}

void main(void) {
    while(1) {
        if (adc_result > 2048) {  // Compiler may cache adc_result!
            // This might never execute!
        }
    }
}

// âœ… GOOD: Use volatile for ISR-shared variables
volatile uint16_t adc_result = 0;  // volatile!
// Now compiler always reads from memory
```

### **Pitfall 3: PWM Update Timing**

```c
// âŒ BAD: Update PWM in wrong part of cycle
void TIMG7_IRQHandler(void) {
    // Timer at zero, PWM cycle just started
    DL_TimerG_setCaptureCompareValue(...);  // Update now
    // May cause glitch if updated mid-cycle!
}

// âœ… GOOD: Update synchronized with PWM period
// PWM automatically loads new value at start of next cycle
// No special synchronization needed if PWM freq << sample rate
```

### **Pitfall 4: Phase Accumulator Overflow**

```c
// âŒ BAD: Phase wraps incorrectly
uint16_t phase = 0;  // Only 16-bit!
phase += phase_increment;
// Wraps at 65536, not 2^32!

// âœ… GOOD: Use 32-bit phase accumulator
uint32_t phase = 0;  // 32-bit
phase += phase_increment;
// Wraps naturally at 2^32
```

### **Pitfall 5: ADC Timing Conflict**

```c
// âŒ BAD: Timer period < ADC conversion time
TIMER1.timerPeriod = "100 us";  // 10 kHz
ADC121.sampleTime0 = "125 us";  // Takes 375 Âµs for 3 channels!

// Timer triggers new conversion before previous finishes!
// Result: Missed samples, corrupted data

// âœ… GOOD: Ensure timer period â‰¥ ADC total time
TIMER1.timerPeriod = "400 us";  // Allow time for 3-channel conversion
// Or use faster ADC sample time:
ADC121.sampleTime0 = "25 us";   // Only 75 Âµs total for 3 channels
```

---

## ğŸš€ 9. ADVANCED TECHNIQUES {#advanced}

### **9.1 DMA for Zero-CPU ADC Transfer**

```javascript
// SysConfig DMA configuration:
DMA1.addressMode = "f2f";  // Fixed to fixed
DMA1.srcAddr = "ADC_MIC_JOY_INST + MEM0";
DMA1.dstAddr = "&adc_buffer[0]";
DMA1.transferMode = "FULL_CH_REPEAT";

// DMA automatically copies ADC results to buffer
// Zero CPU overhead!
```

```c
// Usage:
uint16_t adc_buffer[3];  // DMA destination

void init_dma_adc(void) {
    // DMA transfers ADC results automatically
    // No ADC ISR needed!
}

void TIMG7_IRQHandler(void) {
    // Just read from buffer (DMA already updated it)
    uint16_t joy_x = adc_buffer[2];
    uint16_t joy_y = adc_buffer[1];
    
    // Process...
}
```

### **9.2 Double-Buffering for Glitch-Free Updates**

```c
// Ping-pong buffers for continuous processing:
#define BUFFER_SIZE 128
int16_t audio_buffer_A[BUFFER_SIZE];
int16_t audio_buffer_B[BUFFER_SIZE];

volatile bool use_buffer_A = true;
volatile uint16_t buffer_index = 0;

void TIMG7_IRQHandler(void) {
    // Read from active buffer
    int16_t *active = use_buffer_A ? audio_buffer_A : audio_buffer_B;
    int16_t sample = active[buffer_index++];
    
    // Update PWM
    DL_TimerG_setCaptureCompareValue(PWM_AUDIO_INST, 2048 + sample, 0);
    
    // Switch buffers when current exhausted
    if (buffer_index >= BUFFER_SIZE) {
        buffer_index = 0;
        use_buffer_A = !use_buffer_A;  // Swap
        buffer_ready_flag = true;  // Signal main loop
    }
}

void main(void) {
    while(1) {
        if (buffer_ready_flag) {
            // Fill inactive buffer while ISR plays active buffer
            int16_t *inactive = use_buffer_A ? audio_buffer_B : audio_buffer_A;
            generate_audio_block(inactive, BUFFER_SIZE);
            buffer_ready_flag = false;
        }
        __WFI();
    }
}
```

### **9.3 Fractional Phase Increment (Fine Tuning)**

```c
// High-precision frequency control:
typedef struct {
    uint32_t integer;     // Integer part of phase increment
    uint32_t fractional;  // Fractional part (24-bit)
} phase_inc_t;

phase_inc_t phase_inc;
uint32_t phase = 0;
uint32_t frac_accum = 0;

void calculate_precise_frequency(float freq_hz) {
    // freq_hz = 440.0 Hz (A4 note)
    // phase_inc = (freq * 2^32) / sample_rate
    double phase_inc_float = (freq_hz * 4294967296.0) / 8000.0;
    
    phase_inc.integer = (uint32_t)phase_inc_float;
    phase_inc.fractional = (uint32_t)((phase_inc_float - phase_inc.integer) * 16777216.0);
}

void TIMG7_IRQHandler(void) {
    // Add fractional part with carry
    frac_accum += phase_inc.fractional;
    uint32_t carry = (frac_accum >> 24);  // Extract carry bit
    frac_accum &= 0xFFFFFF;  // Keep only 24 bits
    
    // Add integer part + carry
    phase += phase_inc.integer + carry;
    
    // Generate sample...
}
// Result: Extremely accurate frequency (< 0.01 Hz error)
```

### **9.4 Adaptive Sample Rate**

```c
// Adjust sample rate based on CPU load:
volatile uint32_t isr_duration_max = 0;

void TIMG7_IRQHandler(void) {
    uint32_t start_time = DL_Timer_getTimerCount(TIMER_SAMPLE_INST);
    
    // Do ISR work...
    calculate_audio();
    update_pwm();
    
    uint32_t end_time = DL_Timer_getTimerCount(TIMER_SAMPLE_INST);
    uint32_t duration = start_time - end_time;  // Countdown timer
    
    // Track maximum ISR duration
    if (duration > isr_duration_max) {
        isr_duration_max = duration;
    }
}

void main(void) {
    while(1) {
        // Check if ISR is taking too long
        if (isr_duration_max > 3500) {  // >87.5% of 125Âµs period
            // Reduce sample rate to prevent overruns
            reduce_sample_rate();
        }
        __WFI();
    }
}
```

---

## âœ… SUMMARY CHECKLIST

### **Design Checklist:**

- [ ] Timer period â‰¥ ADC total conversion time
- [ ] ISR execution time < timer period
- [ ] All ISR-shared variables are `volatile`
- [ ] PWM carrier frequency >> audio frequencies
- [ ] Proper interrupt priorities set
- [ ] Low-pass filter on PWM output
- [ ] Power-saving modes used (`__WFI()`)

### **Debug Checklist:**

- [ ] Measure ISR execution time
- [ ] Check for timer overruns
- [ ] Verify ADC timing with oscilloscope
- [ ] Listen for audio glitches (timing problems)
- [ ] Monitor CPU utilization
- [ ] Test at extreme parameter values

### **Performance Metrics:**

```c
// Measure and display in debug:
uint32_t isr_time_avg;     // Average ISR duration
uint32_t isr_time_max;     // Maximum ISR duration
uint32_t cpu_utilization;  // Percentage (0-100)
uint32_t sample_rate_actual;  // Measured sample rate
```

---

## ğŸ“ QUIZ - Test Your Understanding!

**Q1:** Timer period = 125 Âµs, ADC sample time = 50 Âµs, 3 channels. Problem?  
**A:** Total ADC time = 150 Âµs > 125 Âµs. Reduce sample time or increase timer period!

**Q2:** PWM frequency = 1 kHz, audio signal = 500 Hz. Will it work?  
**A:** No! PWM carrier must be >> audio frequency (typically 10Ã—). Use PWM â‰¥ 5 kHz.

**Q3:** ISR updates `frequency` variable. Does main loop need `volatile`?  
**A:** If main loop READS frequency, yes! Use `volatile float frequency`.

**Q4:** How to prevent audio glitches during LCD updates?  
**A:** Move LCD updates to main loop (outside ISR). Use double-buffering if needed.

**Q5:** ADC gives 12-bit result (0-4095). How to center for audio?  
**A:** Subtract 2048: `audio_sample = (int16_t)adc_result - 2048`

---

## ğŸ“š FURTHER READING

- MSPM0 Technical Reference Manual - Timer chapter
- MSPM0 Technical Reference Manual - ADC chapter  
- MSPM0 Technical Reference Manual - DMA chapter
- "Digital Signal Processing" by Oppenheim & Schafer
- "Real-Time Digital Signal Processing" by Sen M. Kuo

**Lykke til med PWM, Timer og ADC samspill!** ğŸµâ°ğŸ”¬
